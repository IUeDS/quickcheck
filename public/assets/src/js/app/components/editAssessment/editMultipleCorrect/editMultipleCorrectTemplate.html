<div>
    <h3 class="qc-question-options-header">Question options <span class="sr-only">for question #{{ vm.question.question_order }}</span></h3>
    <qc-rich-content-toggle ng-if="!vm.readOnly"
        qc-on-rich-content-toggle="vm.onRichContentToggle($event)"
        qc-question="vm.question"
        qc-toggle-type="'options'">
    </qc-rich-content-toggle>
    <div ng-repeat="option in vm.question.options track by $index"
        ng-class="{'qc-rich-content-toggled' : vm.isRichContentToggled }">
        <label for="mc-option-{{vm.question.id}}-{{option.id}}"
            id="mc-option-{{vm.question.id}}-{{option.id}}-label">
            Option #{{ $index+1 }}
            <span class="sr-only">for question #{{ vm.question.question_order }}</span>
        </label>
        <qc-toggle-correct-btn
            qc-index="$index"
            qc-on-toggle-correct="vm.toggleCorrect($event)"
            qc-option="option"
            qc-question="vm.question"
            ng-if="vm.isRichContentToggled">
        </qc-toggle-correct-btn>
        <qc-delete-option-btn
            qc-index="$index"
            qc-on-delete="vm.deleteOption($event)"
            qc-option="option"
            qc-option-type-text="'multiple correct option'"
            qc-question="vm.question"
            ng-if="!vm.readOnly && vm.isRichContentToggled">
        </qc-delete-option-btn>
        <div class="qc-edit-assessment-inline">
            <input type="text" class="form-control"
                ng-if="!vm.isRichContentToggled"
                id="mc-option-{{vm.question.id}}-{{option.id}}"
                ng-model="option.answer_text"
                ng-change="vm.onEdited()"
                required
                ng-disabled="vm.readOnly">
            <textarea ui-tinymce="vm.tinymceOptions"
                ng-if="vm.isRichContentToggled"
                aria-labelled-by="mc-option-{{vm.question.id}}-{{option.id}}-label"
                ng-model="option.answer_text"
                ng-change="vm.onEdited()"
                required>
            </textarea>
            <!-- put correct icon after text input, but float to the left; so that way, sighted users see it from left to right in a way that visually makes sense, but screenreader users see it after, so when they create a new option, focus is moved to the text input, and then they can select if they want it to be correct or not. Otherwise, if we moved focus to the text input and the correct symbol came before, the user would not be aware of its existence -->
            <qc-toggle-correct-btn
                qc-index="$index"
                qc-on-toggle-correct="vm.toggleCorrect($event)"
                qc-option="option"
                qc-question="vm.question"
                ng-if="!vm.isRichContentToggled">
            </qc-toggle-correct-btn>
            <qc-delete-option-btn
                qc-index="$index"
                qc-on-delete="vm.deleteOption($event)"
                qc-option="option"
                qc-option-type-text="'multiple correct option'"
                qc-question="vm.question"
                ng-if="!vm.readOnly && !vm.isRichContentToggled">
            </qc-delete-option-btn>
        </div>
    </div>
    <hr>
    <button class="btn btn-sm btn-primary qc-btn" ng-click="vm.addOption()" type="button" ng-if="!vm.readOnly">
        <span class="fa fa-plus" aria-hidden="true"></span> Add option
        <span class="sr-only">for question #{{ vm.question.question_order }}</span>
    </button>
    <qc-custom-feedback ng-if="!vm.readOnly"
        qc-on-question-edited="vm.onSubComponentEdited($event)"
        qc-question="vm.question">
    </qc-custom-feedback>
    <hr>
    <qc-randomize-checkbox
        qc-on-question-edited="vm.onSubComponentEdited($event)"
        qc-question="vm.question"
        qc-read-only="vm.readOnly">
</div>